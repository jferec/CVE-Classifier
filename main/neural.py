import numpy as np
from parsing import bag_of_words
from main import knowledge


def sigmoid(x):
    """
    Oblicza wartosc funkcji sigmoid
    :param x: parametr funkcji
    :return: wartosc funkcji
    """
    output = 1 / (1 + np.exp(-x))
    return output


def sigmoid_output_to_derivative(output):
    """
    Oblicza pochdodna wartosci funkcji sigmoid
    :param output: wartosc funkcji
    :return: wartosc pochodnej
    """
    return output * (1 - output)


def think(vector, synapse_0, synapse_1):
    """
    Oblicza wartosc warstwy l2 dla podanego wektora binarnego
    :param vector: wektor binarny
    :param synapse_0: wartosc synapsy
    :param synapse_1: wartosc synapsy
    :return: wartosc na warstwie l2
    """
    vector = np.array(vector, dtype='float64')
    synapse_0 = np.array(synapse_0, dtype='float64')
    l0 = vector
    l1 = sigmoid(np.dot(l0, synapse_0))
    l2 = sigmoid(np.dot(l1, synapse_1))
    return l2


def classify(file_name):
    """
    Klasyfikuje dane z pliku zrodlowego
    :param file_name: nazwa pliku zrodlowego
    :return: dla kazdej linii: przydzielona klasa i procent pewnosci ze wynik jest prawidlowy
    """
    data = knowledge.Knowledge("knowledge.json")
    bag = bag_of_words.BagOfWords(data.dictionary)
    vectors = bag.get_binary_vectors(file_name)
    with open('../text_files/' + file_name, 'r') as input_file:
        input_data = input_file.read()
    lines = input_data.splitlines()

    for i, vector in enumerate(vectors):
        results = think(vector, data.synapse_0, data.synapse_1)
        results = [[i, r] for i, r in enumerate(results) if r > 0.2]
        results.sort(key=lambda x: x[1], reverse=True)
        return_results = [[data.classes[r[0]], r[1]] for r in results]
        print("%s \n classification: %s \n" % (lines[i], return_results))


classify("dictionary.txt")
